# -*- coding: utf-8 -*-
"""MLrecomendaciones Arbol.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v-88yZPGnb-Cj22rTo4lfXdLcHgHproC
"""

import requests
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.tree import DecisionTreeClassifier
from sklearn.tree import export_graphviz

# Función para obtener los lugares más cercanos utilizando el API de Google Places
def obtener_lugares_cercanos(api_key, ubicacion, radio, tipo):
    url = "https://maps.googleapis.com/maps/api/place/nearbysearch/json"
    parametros = {
        "key": api_key,
        "location": ubicacion,
        "radius": radio,
        "type": tipo
    }
    respuesta = requests.get(url, params=parametros)
    datos = respuesta.json()

    lugares = []
    for resultado in datos["results"]:
        nombre = resultado["name"]
        comentario = resultado["vicinity"]
        lugares.append({"nombre": nombre, "comentario": comentario})

    return lugares

#de uso para obtener los lugares más cercanos
api_key = "AIzaSyDg-wPcQS53-98Rq-RKxcOV2ZP-6JC1ifs"
ubicacion = "-12.049740752171363, -75.19665944977362"
radio = 1000  # Radio en metros para buscar lugares cercanos
tipo = "restaurant"  # Tipo de lugar a buscar

lugares = obtener_lugares_cercanos(api_key, ubicacion, radio, tipo)

#  DataFrame con los datos obtenidos de los lugares
df = pd.DataFrame(lugares)

# Crear la matriz TF-IDF
tfidf_vectorizer = TfidfVectorizer()
tfidf_matrix = tfidf_vectorizer.fit_transform(df['comentario'])

# Ajustar el modelo de árbol de decisiones
arbol_decision = DecisionTreeClassifier()
arbol_decision.fit(tfidf_matrix, df['nombre'])

# Función para obtener recomendaciones usando el árbol de decisiones
def obtener_recomendaciones_arbol(n, lugar):
    comentario_tf_idf = tfidf_vectorizer.transform([lugar])
    lugar_predicho = arbol_decision.predict(comentario_tf_idf)[0]
    lugares_filtrados = df[df['nombre'] == lugar_predicho].reset_index(drop=True)

    if len(lugares_filtrados) == 0:
        print("No se encontraron lugares con el tipo especificado.")
        return None
    elif len(lugares_filtrados) < n:
        lugares_indices = list(range(len(lugares_filtrados)))
    else:
        lugares_indices = list(range(n))

    return lugares_filtrados.iloc[lugares_indices]

#obtención de recomendaciones usando el árbol de decisiones
n = 5
comentario_lugar = "Comentarios sobre el lugar"
recomendaciones_arbol = obtener_recomendaciones_arbol(n, comentario_lugar)
print(recomendaciones_arbol)

export_graphviz(arbol_decision, out_file="tree1.dot")

modelo.save("modelo_entrenado")

import graphviz
from IPython.display import Image
from sklearn.tree import export_graphviz
from sklearn.metrics import accuracy_score

import os


# Cargar el archivo .dot generado por export_graphviz
with open("tree1.dot") as f:
    dot_graph = f.read()

# Crear el gráfico del árbol
graph = graphviz.Source(dot_graph)

# Guardar el gráfico en un archivo PNG
graph.render(filename="tree1", format="png", cleanup=True)

# Mostrar el gráfico en Jupyter Notebook
Image("tree1.png")
# Obtener el directorio de trabajo actual
directorio_actual = os.getcwd()

# Verificar si el archivo "tree1.dot" se encuentra en el directorio actual
ruta_completa = os.path.join(directorio_actual, "tree1.dot")
if os.path.exists(ruta_completa):
    print("El archivo 'tree1.dot' se encuentra en la ubicación correcta.")
else:
    print("No se encontró el archivo 'tree1.dot' en la ubicación actual.")

predicted_values = arbol_decision.predict(tfidf_matrix)
accuracy = accuracy_score(df['nombre'], predicted_values)
print("Nivel de predicción:", accuracy)

# sklearn.metrics.accuracy_score usar esta libreria para el nivel de precision